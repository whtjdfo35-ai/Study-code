<!DOCTYPE html>
<html>

<head>
    <title>졸라맨 격투 - 최종 디테일 업데이트</title>
    <style>
        body {
            text-align: center;
            background: #1a1a1a;
            color: white;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        canvas {
            background: #fff;
            border: 5px solid #444;
            display: block;
            margin: 10px auto;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .ui {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 800px;
            margin: 0 auto;
            padding: 10px;
            gap: 20px;
        }

        .hp-container {
            width: 300px;
            background: #444;
            border: 2px solid #fff;
            height: 20px;
            overflow: hidden;
        }

        .hp-bar {
            height: 100%;
            width: 100%;
            transition: width 0.2s;
        }

        #p1-hp {
            background: #007bff;
        }

        #p2-hp {
            background: #dc3545;
        }

        .danger {
            border-color: #ff0000;
            box-shadow: 0 0 15px #ff0000;
            animation: pulse-danger 0.5s infinite alternate;
        }

        @keyframes pulse-danger {
            from {
                opacity: 0.7;
            }

            to {
                opacity: 1;
            }
        }

        #timer {
            font-size: 32px;
            font-weight: bold;
            min-width: 80px;
            color: #f1c40f;
        }

        #timer.urgent {
            color: #ff0000;
            font-size: 48px;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        #victory-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            text-shadow: 3px 3px 5px #000;
            display: none;
            z-index: 10;
        }
    </style>
</head>

<body>
    <div id="victory-screen"></div>
    <h1>Stickman Duel: X-Eyes Edition</h1>
    <div class="ui">
        <div>P1<div id="p1-container" class="hp-container">
                <div id="p1-hp" class="hp-bar"></div>
            </div>
        </div>
        <div id="timer">60</div>
        <div>P2<div id="p2-container" class="hp-container">
                <div id="p2-hp" class="hp-bar"></div>
            </div>
        </div>
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gravity = 0.8;
        const projectiles = [];
        const effects = [];
        let timeLeft = 60;
        let gameOver = false;

        const timerInterval = setInterval(() => {
            if (!gameOver) {
                timeLeft--;
                document.getElementById('timer').innerText = timeLeft;
                if (timeLeft <= 10) document.getElementById('timer').classList.add('urgent');
                if (timeLeft <= 0) determineWinner("TIME OVER!");
            }
        }, 1000);

        // ... (위쪽 HTML 및 스타일 코드는 동일) ...

        class Fighter {
            constructor({ position, color, side, playerNum }) {
                this.position = position;
                this.velocity = { x: 0, y: 0 };
                this.width = 50; this.height = 100;
                this.color = color;
                this.health = 100;
                this.side = side;
                this.isAttacking = false;
                this.attackType = '';
                this.isBlocking = false;
                this.isCrouching = false;
                this.isStunned = false;
                this.stunType = '';
                this.isShootingReady = true;
                this.onGround = false;
                this.playerNum = playerNum;
                this.rotation = 0;
                this.attackCount = 0; // [추가] 공격 순서 추적 변수
            }

            draw() {
                ctx.save();
                let px = this.position.x + 25;
                let py = this.position.y;

                if (this.health <= 0) {
                    ctx.translate(px, canvas.height - 5);
                    ctx.rotate(this.rotation);
                    ctx.translate(-px, -(canvas.height - 5) - 15);
                }

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';

                let dir = (this.side === 'left') ? 1 : -1;
                let isActuallyCrouching = this.isCrouching && !this.isStunned && this.health > 0;
                let crouchOffset = isActuallyCrouching ? 40 : 0;
                let leanOffset = (this.isBlocking && !this.isStunned) ? 8 * dir : 0;

                // --- 1. 머리 & 일자 입 ---
                ctx.beginPath();
                ctx.arc(px + leanOffset, py + 22 + crouchOffset, 15, 0, Math.PI * 2);
                ctx.stroke();

                if (this.health > 0) {
                    ctx.beginPath();
                    ctx.lineWidth = 2;
                    ctx.moveTo(px + leanOffset + (3 * dir), py + 30 + crouchOffset);
                    ctx.lineTo(px + leanOffset + (13 * dir), py + 30 + crouchOffset);
                    ctx.stroke();
                    ctx.lineWidth = 5;
                }

                // --- 2. 눈 ---
                if (this.health <= 0) {
                    ctx.lineWidth = 2;
                    let eyeX = px + leanOffset + (7 * dir);
                    let eyeY = py + 20 + crouchOffset;
                    ctx.beginPath(); ctx.moveTo(eyeX - 4, eyeY - 4); ctx.lineTo(eyeX + 4, eyeY + 4); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(eyeX + 4, eyeY - 4); ctx.lineTo(eyeX - 4, eyeY + 4); ctx.stroke();
                    ctx.lineWidth = 5;
                } else {
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(px + leanOffset + (7 * dir), py + 20 + crouchOffset, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // --- 3. 몸통 ---
                ctx.beginPath();
                ctx.moveTo(px + leanOffset, py + 37 + crouchOffset);
                ctx.lineTo(px, py + 75 + (crouchOffset > 0 ? 10 : 0));
                ctx.stroke();

                // --- 4. 팔 (공격 시 반대 팔 대기 상태 유지) ---
                ctx.beginPath();

                if (this.isBlocking && !this.isStunned && this.health > 0) {
                    ctx.moveTo(px + leanOffset, py + 45 + crouchOffset);
                    ctx.lineTo(px + leanOffset + 25 * dir, py + 25 + crouchOffset);
                    ctx.moveTo(px + leanOffset, py + 50 + crouchOffset);
                    ctx.lineTo(px + leanOffset + 20 * dir, py + 40 + crouchOffset);
                }
                else if (this.isStunned && this.health > 0 && this.stunType === 'shoot') {
                    ctx.moveTo(px + leanOffset, py + 42 + crouchOffset);
                    ctx.lineTo(px + leanOffset + 35 * dir, py + 42 + crouchOffset);
                    ctx.moveTo(px + leanOffset, py + 52 + crouchOffset);
                    ctx.lineTo(px + leanOffset + 35 * dir, py + 52 + crouchOffset);
                }
                else if (this.isAttacking && this.attackType === 'high') {
                    const reach = (this.side === 'left') ? 65 : -15;

                    if (this.attackCount % 2 === 1) {
                        // [앞쪽 팔 공격]
                        ctx.moveTo(px + leanOffset, py + 45 + crouchOffset);
                        ctx.lineTo(this.position.x + reach, py + 42 + crouchOffset);
                        // [뒤쪽 팔은 대기] - 기본 상태 좌표 유지
                        ctx.moveTo(px + leanOffset, py + 45 + crouchOffset);
                        ctx.lineTo(px - 15 * dir, py + 65 + crouchOffset);
                    } else {
                        // [뒤쪽 팔 공격]
                        ctx.moveTo(px + leanOffset, py + 45 + crouchOffset);
                        ctx.lineTo(this.position.x + reach, py + 55 + crouchOffset);
                        // [앞쪽 팔은 대기] - 기본 상태 좌표 유지
                        ctx.moveTo(px + leanOffset, py + 45 + crouchOffset);
                        ctx.lineTo(px + 15 * dir, py + 65 + crouchOffset);
                    }
                }
                else {
                    // 기본 상태
                    ctx.moveTo(px + leanOffset, py + 45 + crouchOffset);
                    ctx.lineTo(px + 15 * dir, py + 65 + crouchOffset); // 앞팔
                    ctx.moveTo(px + leanOffset, py + 45 + crouchOffset);
                    ctx.lineTo(px - 15 * dir, py + 65 + crouchOffset); // 뒷팔
                }
                ctx.stroke();

                // --- 5. 다리 (공격 시 반대 다리 지탱 상태 유지) ---
                ctx.beginPath();
                if (this.isAttacking && this.attackType === 'low') {
                    const reach = (this.side === 'left') ? 75 : -25;
                    const hipY = py + 75 + (crouchOffset > 0 ? 10 : 0);

                    if (this.attackCount % 2 === 1) {
                        // [앞다리 발차기]
                        ctx.moveTo(px, hipY);
                        ctx.lineTo(this.position.x + reach, py + 95);
                        // [뒷다리 지탱] - 기본 상태 유지
                        ctx.moveTo(px, hipY);
                        ctx.lineTo(px - 15, py + 100);
                    } else {
                        // [뒷다리 발차기]
                        ctx.moveTo(px, hipY);
                        ctx.lineTo(this.position.x + reach, py + 85);
                        // [앞다리 지탱] - 기본 상태 유지
                        ctx.moveTo(px, hipY);
                        ctx.lineTo(px + 15, py + 100);
                    }
                } else if (crouchOffset > 0) {
                    ctx.moveTo(px, py + 85); ctx.lineTo(px - 20, py + 100);
                    ctx.moveTo(px, py + 85); ctx.lineTo(px + 20, py + 100);
                } else {
                    ctx.moveTo(px, py + 75); ctx.lineTo(px - 15, py + 100);
                    ctx.moveTo(px, py + 75); ctx.lineTo(px + 15, py + 100);
                }
                ctx.stroke();

                ctx.restore();
            }
            // ... (update 메서드는 동일) ...
            update() {
                if (this.health <= 0) {
                    if (Math.abs(this.rotation) < Math.PI / 2) {
                        this.rotation += (this.side === 'left' ? -0.1 : 0.1);
                    }
                }
                this.draw();
                if (!this.isStunned && this.health > 0) this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                if (this.position.y + this.height + this.velocity.y >= canvas.height) {
                    this.velocity.y = 0; this.position.y = canvas.height - this.height; this.onGround = true;
                } else {
                    this.velocity.y += gravity; this.onGround = false;
                }
            }

            attack(type) {
                if (this.isBlocking || this.isStunned || this.isAttacking || gameOver) return;
                this.attackType = type;
                this.attackCount++; // [수정] 공격 시마다 카운트 증가

                setTimeout(() => {
                    if (this.health > 0) {
                        this.isAttacking = true;
                        setTimeout(() => { this.isAttacking = false; }, 150);
                    }
                }, type === 'low' ? 100 : 0);
            }

            // ... (shoot 및 나머지 코드는 동일) ...
            shoot() {
                if (!this.isShootingReady || this.isBlocking || this.isStunned || gameOver) return;
                this.isShootingReady = false;
                this.isStunned = true;
                this.stunType = 'shoot';
                setTimeout(() => {
                    if (this.health > 0) {
                        projectiles.push({
                            x: (this.side === 'left') ? this.position.x + 60 : this.position.x - 10,
                            y: this.position.y + (this.isCrouching ? 87 : 47),
                            vx: (this.side === 'left') ? 12 : -12,
                            owner: this.playerNum
                        });
                    }
                }, 60);
                setTimeout(() => { this.isStunned = false; }, 400);
            }
        }
        // ... (이하 애니메이션 및 로직 동일) ...

        const p1 = new Fighter({ position: { x: 150, y: 0 }, color: '#007bff', side: 'left', playerNum: 1 });
        const p2 = new Fighter({ position: { x: 600, y: 0 }, color: '#dc3545', side: 'right', playerNum: 2 });
        const keys = { a: 0, d: 0, s: 0, comma: 0, dot: 0, Left: 0, Right: 0, Down: 0, n1: 0, n2: 0 };

        function createEffect(x, y) { effects.push({ x, y, life: 12 }); }

        window.addEventListener('keydown', (e) => {
            if (gameOver) return;
            if (e.key === 'a') keys.a = 1; if (e.key === 'd') keys.d = 1; if (e.key === 's') p1.isCrouching = true;
            if (e.key === 'w' && p1.onGround) p1.velocity.y = -13.5;
            if (e.key === ',') keys.comma = 1; if (e.key === '.') keys.dot = 1;
            if (e.key === '/') p1.isBlocking = true;
            if (e.key === 'ArrowLeft') keys.Left = 1; if (e.key === 'ArrowRight') keys.Right = 1;
            if (e.key === 'ArrowDown') p2.isCrouching = true;
            if (e.key === 'ArrowUp' && p2.onGround) p2.velocity.y = -13.5;
            if (e.key === '1') keys.n1 = 1; if (e.key === '2') keys.n2 = 1;
            if (e.key === '3') p2.isBlocking = true;
            if (keys.comma && keys.dot) p1.shoot();
            if (keys.n1 && keys.n2) p2.shoot();
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'a') keys.a = 0; if (e.key === 'd') keys.d = 0; if (e.key === 's') p1.isCrouching = false;
            if (e.key === ',') { if (!keys.dot && keys.comma) p1.attack('high'); keys.comma = 0; p1.isShootingReady = true; }
            if (e.key === '.') { if (!keys.comma && keys.dot) p1.attack('low'); keys.dot = 0; p1.isShootingReady = true; }
            if (e.key === '/') p1.isBlocking = false;
            if (e.key === 'ArrowLeft') keys.Left = 0; if (e.key === 'ArrowRight') keys.Right = 0;
            if (e.key === 'ArrowDown') p2.isCrouching = false;
            if (e.key === '1') { if (!keys.n2 && keys.n1) p2.attack('high'); keys.n1 = 0; p2.isShootingReady = true; }
            if (e.key === '2') { if (!keys.n1 && keys.n2) p2.attack('low'); keys.n2 = 0; p2.isShootingReady = true; }
            if (e.key === '3') p2.isBlocking = false;
        });

        function checkMeleeHit(attacker, victim) {
            if (attacker.isAttacking && victim.health > 0) {
                if (victim.isCrouching && attacker.attackType === 'high') return;
                if (attacker.attackType === 'low' && !victim.onGround) return;
                let reach = attacker.attackType === 'high' ? 55 : 75;
                let attackX = (attacker.side === 'left') ? attacker.position.x + 30 : attacker.position.x - reach + 20;
                let attackY = attacker.position.y + (attacker.attackType === 'high' ? 40 : 90);
                if (attackX < victim.position.x + 50 && attackX + reach > victim.position.x &&
                    attackY >= victim.position.y + (victim.isCrouching ? 40 : 0) && attackY <= victim.position.y + 100) {
                    let contactX = (attacker.side === 'left') ? Math.min(attackX + reach, victim.position.x + 50) : Math.max(attackX, victim.position.x);
                    createEffect(contactX, attackY);
                    if (!(victim.isBlocking && ((attacker.side === 'left' && victim.side === 'right') || (attacker.side === 'right' && victim.side === 'left')))) {
                        victim.health -= (attacker.attackType === 'high' ? 10 : 15);
                        if (victim.isCrouching && attacker.attackType === 'low') {
                            victim.isCrouching = false;
                            victim.isStunned = true;
                            victim.stunType = 'hit';
                            setTimeout(() => { victim.isStunned = false; }, 800);
                        }
                    }
                    attacker.isAttacking = false; updateHP();
                }
            }
        }

        function updateHP() {
            document.getElementById('p1-hp').style.width = Math.max(0, p1.health) + '%';
            document.getElementById('p2-hp').style.width = Math.max(0, p2.health) + '%';
            if (p1.health <= 20) document.getElementById('p1-container').classList.add('danger');
            if (p2.health <= 20) document.getElementById('p2-container').classList.add('danger');
            if (p1.health <= 0 || p2.health <= 0) determineWinner("KO!");
        }

        function determineWinner(reason) {
            if (gameOver) return; gameOver = true; clearInterval(timerInterval);
            let msg = reason + (p1.health > p2.health ? " P1 WIN!" : " P2 WIN!");
            if (p1.health === p2.health) msg = reason + " DRAW!";
            const screen = document.getElementById('victory-screen');
            screen.innerHTML = msg; screen.style.color = (p1.health > p2.health) ? "#007bff" : "#dc3545";
            screen.style.display = "block";
        }

        function animate() {
            window.requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#444'; ctx.fillRect(0, canvas.height - 5, canvas.width, 5);
            p1.update(); p2.update();

            for (let i = effects.length - 1; i >= 0; i--) {
                const ef = effects[i]; ctx.fillStyle = `rgba(255, 60, 0, ${ef.life / 12})`; ctx.beginPath();
                for (let j = 0; j < 8; j++) {
                    let a = (Math.PI * 2 / 8) * j;
                    ctx.lineTo(ef.x + Math.cos(a) * (15 - ef.life) * 2, ef.y + Math.sin(a) * (15 - ef.life) * 2);
                }
                ctx.fill(); ef.life--; if (ef.life <= 0) effects.splice(i, 1);
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i]; p.x += p.vx;
                ctx.fillStyle = p.owner === 1 ? '#007bff' : '#dc3545';
                ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, Math.PI * 2); ctx.fill();
                const target = p.owner === 1 ? p2 : p1;
                if (p.x > target.position.x && p.x < target.position.x + 50 && p.y > target.position.y && p.y < target.position.y + 100) {
                    createEffect(p.x, p.y);
                    if (!target.isBlocking) target.health -= 12;
                    projectiles.splice(i, 1); updateHP();
                } else if (p.x < 0 || p.x > canvas.width) projectiles.splice(i, 1);
            }

            if (!gameOver) {
                p1.velocity.x = (keys.a ? -5 : 0) + (keys.d ? 5 : 0);
                if (keys.a) p1.side = 'right'; if (keys.d) p1.side = 'left';
                p2.velocity.x = (keys.Left ? -5 : 0) + (keys.Right ? 5 : 0);
                if (keys.Left) p2.side = 'right'; if (keys.Right) p2.side = 'left';
                checkMeleeHit(p1, p2); checkMeleeHit(p2, p1);
            }
        }
        animate();
    </script>
</body>

</html>