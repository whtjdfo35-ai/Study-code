SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION ALL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10;

SELECT * FROM EMP WHERE DEPTNO =10 OR DEPTNO =20;

SELECT * FROM EMP 
WHERE DEPTNO IN (10,20);

SELECT * FROM EMP
WHERE DEPTNO NOT IN (10,20);

SELECT * FROM EMP
WHERE SAL BETWEEN 2000 AND 3000;

SELECT * FROM EMP
WHERE SAL >=2000 AND SAL <= 3000;

--p130. Q1
SELECT * FROM EMP
WHERE ENAME LIKE '%S';

--Q2
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO = 30
AND JOB = 'SALESMAN';

--Q3
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO IN (20,30)
AND SAL >2000;

--Q3
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO IN (20,30)
MINUS
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE
SAL <= 2000;

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO = 20 AND SAL> 2000
UNION 
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP
WHERE DEPTNO = 30 AND SAL> 2000;

--Q4
SELECT * FROM EMP
WHERE SAL < 2000 OR SAL > 3000;

SELECT * FROM EMP
WHERE NOT (SAL >= 2000 AND SAL <=3000);

SELECT * FROM EMP
WHERE SAL NOT BETWEEN 2000 AND 3000;

--Q5
SELECT ENAME, EMPNO, SAL, DEPTNO FROM EMP
WHERE ENAME LIKE '%E%' 
AND DEPTNO = 30 
AND SAL <=1000
UNION 
SELECT ENAME, EMPNO, SAL, DEPTNO FROM EMP
WHERE ENAME LIKE '%E%' 
AND DEPTNO = 30 
AND SAL >=2000;

SELECT ENAME, EMPNO, SAL, DEPTNO FROM EMP
WHERE ENAME LIKE '%E%' 
AND DEPTNO = 30 
AND SAL NOT BETWEEN 1000 AND 2000;

--Q6
SELECT * FROM EMP
WHERE COMM IS NULL 
AND MGR IS NOT NULL 
AND JOB IN ('MANAGER','CLERK')
AND ENAME NOT LIKE '_L%';

SELECT * FROM EMP
WHERE DEPTNO IN (20,30)
AND SAL BETWEEN 2000 AND 3000
ORDER BY SAL, ENAME;

SELECT * FROM EMP
WHERE ENAME LIKE '__A%';

SELECT ENAME AS EMPLOYEE_NAME, DEPTNO AS DEPARTMENT_NO  FROM EMP
ORDER BY DEPTNO, ENAME;

---함수
SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME)
FROM EMP;

SELECT LOWER(ENAME, JOB)
FROM EMP;
--에러

SELECT 1
FROM DUAL;
--DUAL은 한 칸 짜리 임시 테이블
SELECT UPPER('aBc'), LOWER('aBc') FROM DUAL;

SELECT * FROM EMP
WHERE ENAME LIKE '%AM%';

SELECT * FROM EMP
WHERE LOWER(ENAME) LIKE LOWER('%AM%');

SELECT ENAME, LENGTH(ENAME)
FROM EMP;

SELECT ENAME, LENGTH(ENAME)
FROM EMP 
WHERE LENGTH(ENAME) >= 5;

SELECT LENGTH('한글'), LENGTHB('한글')
FROM DUAL;

--25.12.16---------------------------

SELECT *
FROM emp
WHERE lower(ename) LIKE lower('%a%e%');

SELECT JOB, SUBSTR(JOB,1,20), SUBSTR(JOB,3,2), SUBSTR(JOB,5)
FROM EMP;

SELECT SUBSTR(ENAME,3)
FROM EMP;
--시작 위치가 범위를 넘어가면 NULL, 추출갯수는 많아도 상관 없음

SELECT 'A-B-C' AS REPLACE_BEFORE,
replace('A-B-C','-',' ') AS REPLACE_1,
REPLACE('A-B-C', '-') AS REPLACE_2
FROM DUAL;

SELECT ENAME, REPLACE(ename, 'A', 'abc')
FROM EMP;

SELECT ENAME, REPLACE(ENAME, 'A', 'abc')
FROM EMP
WHERE ENAME LIKE '%A%';

SELECT LPAD(ENAME, 10, '#'), LPAD(ENAME,5,'#')	
FROM EMP;

SELECT RPAD(ENAME, 10, '123456789AB')
FROM EMP;
--PAD는 자릿수 넘어가는 데이터는 짤림, 채울 문자는 자릿수 넘어도 상관없음

--DISCORD Q1
SELECT ENAME, SUBSTR(ENAME,1,2)
FROM EMP;

SELECT ENAME, RPAD(ENAME,2)
FROM EMP;

SELECT ENAME, REPLACE(ENAME,SUBSTR(ENAME,3))
FROM EMP;

--Q2
SELECT ENAME, RPAD(SUBSTR(ENAME,1,2),6,'*')
FROM EMP;

--Q3
SELECT ENAME, RPAD(SUBSTR(ENAME,1,2), LENGTH(ENAME),'*')
FROM EMP;

SELECT EMPNO, ENAME, CONCAT(EMPNO, ENAME), CONCAT(EMPNO,CONCAT(':',ENAME))
FROM EMP 
WHERE ENAME='SCOTT';

SELECT EMPNO || ENAME, EMPNO || ':' || ENAME
FROM EMP;

SELECT 'AB' || 'CD' 
FROM DUAL;

--Q4
SELECT ENAME, '**' || SUBSTR(ENAME,3)
FROM EMP;

SELECT ENAME, LPAD(SUBSTR(ENAME,3), LENGTH(ENAME), '*')
FROM EMP;

SELECT '[' || '  _  _ORACLE_  _  ' || ']',
'[' || TRIM('  _  _ORACLE_  _  ') || ']'
FROM DUAL;

--숫자함수
SELECT ROUND(14.46), ROUND(14.46,1), ROUND(14.46, -1), ROUND(-14.46,1)
FROM DUAL;

SELECT TRUNC(14.46), TRUNC(14.46, 1), TRUNC(14.46, -1), TRUNC(-14.46)
FROM DUAL;

SELECT CEIL(3.14), FLOOR(3.14), CEIL(-3.14), FLOOR(-3.14), TRUNC(-3.14)
FROM DUAL;
--ROUND 반올림 TRUNC 버림 CEIL 지정된 숫자에서 가장 가깝고 큰 정수 FLOOR 지정된 숫자에서 가장 가깝고 작은 정수
--CEIL/FLOOR를 사용할때는 하나의 프로그램에서 하나만 사용하자
--프로그램을 혼용하거나 CEIL/FLOOR 혼용시 계산 값이 틀려질 수 있다

SELECT MOD(15,6), MOD(15,0)
FROM DUAL;
--일반적으로 0으로 나누려 하면 에러 뜨는데 MOD는 분모가 분자보다 작아질때까지 빼고 남은 숫자를 보여주는거라 0으로 나누면 분모가 그대로 나옴

SELECT MOD(6,3), MOD(7,3), MOD(8,3), MOD(9,3)
FROM DUAL;

SELECT SYSDATE 
FROM DUAL;

SELECT EMPNO, ENAME, HIREDATE, ADD_MONTHS(HIREDATE,120)
FROM EMP;
--ADD_YEARS 안됨

--TO_CHAR "형식을 지정"해서 문자로 바꿈)
SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS')
FROM DUAL;

SELECT TO_CHAR(HIREDATE,'YY/MM/DD')
FROM EMP;

SELECT TO_CHAR(SYSDATE, 'YYYY"년" MM"월" DD"일" HH24"시" MI"분" SS"초"')
FROM DUAL;
--한글은 쌍따옴표로 감싸야 에러 안 남 

SELECT *
FROM EMP
WHERE HIREDATE > TO_DATE('1981/06/01', 'YYYY/MM/DD')
ORDER BY HIREDATE;

--NULL 처리함수
SELECT SAL,COMM,SAL+COMM, 
NVL(COMM,0), SAL+NVL(COMM,0), NVL(TO_CHAR(COMM), 'N/A')
FROM EMP;

SELECT COMM, NVL2(COMM,'O', 'X')
FROM EMP;

--DECODE는 IF랑 비슷
SELECT ENAME,JOB, SAL,
	DECODE(JOB,
		'MAMAGER', SAL*1.1,
		'SALESMAN', SAL*1.05,
		'ANALYST' , SAL, 
		SAL*1.03)
FROM EMP;

SELECT JOB, SAL,
	CASE JOB
		WHEN 'MANAGER' THEN SAL*1.1
		WHEN 'SALESMAN' THEN SAL*1.05
		WHEN 'ANALYST' THEN SAL 
		ELSE SAL*1.03
	END 
FROM EMP;
---CASE로 시작하면 END로 닫아야 함/ WHEN THEN은 페어

SELECT COMM,
	CASE
		WHEN COMM IS NULL THEN '해당 사항 없음'
		WHEN COMM = 0 THEN '수당 없음'
		WHEN COMM > 0 THEN '수당 : ' || COMM
	END
FROM EMP;
--DECODE는 EQUAL 만 조건으로 걸수 있음

--P.179 Q1
SELECT 
	EMPNO, 
	LPAD(EMPNO,2) || '**' AS MASKING_EMPNO,  ENAME, 
	RPAD(SUBSTR(ENAME,1,1), LENGTH(ENAME), '*') AS MASKING_ENAME
FROM EMP
WHERE LENGTH(ENAME) = 5;


--Q2
SELECT 
	TO_CHAR(EMPNO,'9999') AS EMPNO,
	ENAME, 
	TO_CHAR(SAL,'9999') AS SAL,
	TRUNC (SAL/21.5,2) AS DAY_PAY,
	ROUND (SAL/(21.5*8),1) AS TIME_PAY
FROM EMP;

--Q3
SELECT
	TO_CHAR(EMPNO, '9999') AS EMPNO, 
	ENAME, 
	TO_CHAR(HIREDATE, 'YY/MM/DD') AS HIREDATE,
	TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE,3), '월요일'), 'YYYY-MM-DD') AS R_JOB,
	CASE 
		WHEN COMM IS NULL THEN 'N/A'
		ELSE TO_CHAR(COMM)
	END AS COMM
FROM EMP; 

--Q4
SELECT
	TO_CHAR(EMPNO) AS EMPNO,
	ENAME, 
	TO_CHAR(MGR) AS MGR,
	CASE 
		WHEN MGR IS NULL THEN '0000'
		WHEN LPAD(MGR,2) = 75 THEN '5555'
		WHEN LPAD(MGR,2) = 76 THEN '6666'
		WHEN LPAD(MGR,2) = 77 THEN '7777'
		WHEN LPAD(MGR,2) = 78 THEN '8888'
		ELSE TO_CHAR(MGR)
	END	AS CHG_MGR
FROM EMP;

SELECT
	TO_CHAR(EMPNO, '9999') AS EMPNO,
	ENAME, 
	TO_CHAR(MGR, '9999') AS MGR,
	CASE 
		WHEN MGR IS NULL THEN '0000'
		WHEN MGR>= 7500 AND MGR < 7600 THEN '5555'
		WHEN MGR>= 7600 AND MGR < 7700 THEN '6666'
		WHEN MGR>= 7700 AND MGR < 7800 THEN '7777'
		WHEN MGR>= 7800 AND MGR < 7900 THEN '8888'
		ELSE TO_CHAR(MGR)
	END	AS CHG_MGR
FROM EMP;
--7800 <= MGR <7900 -ERROR

SELECT
	TO_CHAR(EMPNO, '9999') AS EMPNO,
	ENAME, 
	TO_CHAR(MGR, '9999') AS MGR ,
	CASE MGR
		WHEN  IS NULL THEN '0000'
		WHEN >= 7500 AND  < 7600 THEN '5555'
		WHEN >= 7600 AND  < 7700 THEN '6666'
		WHEN >= 7700 AND  < 7800 THEN '7777'
		WHEN >= 7800 AND  < 7900 THEN '8888'
		ELSE MGR
	END	AS CHG_MGR
FROM EMP;
--이거 안됨 CASE에서 앞으로 빼려면 DECODE처럼 같다 로만 조건 걸어야 하는듯?


SELECT * FROM  dept;
SELECT * FROM emp;

SELECT * FROM EMP,DEPT ORDER BY EMPNO;
--두 테이블의 ROW의 조합만큼 ROW가 생김

SELECT *
FROM EMP,DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;


SELECT ename, e.deptno
FROM EMP E, DEPT D
--별칭을 붙일때 AS 못 씀
WHERE E.DEPTNO = D.DEPTNO;

SELECT SCOTT1_16.EMP.EMPNO FROM SCOTT1_16.EMP
--사용자명.테이블명.칼럼명 순으로 주소가 된다

SELECT * FROM SALGRADE;

SELECT SAL FROM EMP WHERE ENAME = 'SMITH';

SELECT ENAME, SAL, GRADE, LOSAL, HISAL FROM EMP E, SALGRADE S
WHERE E.SAL >= S.LOSAL AND E.SAL <= S.HISAL;
--WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT * FROM EMP WHERE EMPNO = 7902;

SELECT E1.EMPNO, E1.ENAME, E1.MGR,
E2. EMPNO, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;
--NULL은 = 연산에서 빠짐

SELECT *
FROM  EMP E NATURAL JOIN DEPT D;

SELECT *
FROM  EMP E JOIN DEPT D USING (DEPTNO);

SELECT *
FROM  EMP E JOIN DEPT D ON (E.DEPTNO =  D.DEPTNO)
WHERE SAL <= 2000;


SELECT *
FROM  EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO);

SELECT *
FROM  EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO);


--Q
--각 부서별로
--급여가 가장 높은/낮은 사원의 급여 출력
SELECT  MAX(SAL), MIN(SAL), (MAX(SAL)-MIN(SAL)), DEPTNO
FROM EMP
GROUP BY DEPTNO;

--P.226 Q1
SELECT  E.DEPTNO, DNAME, EMPNO, ENAME, SAL FROM EMP E, DEPT D
WHERE SAL >= 2000 AND E.DEPTNO = D.DEPTNO 
ORDER BY DEPTNO;

SELECT  E.DEPTNO, DNAME, EMPNO, ENAME, SAL 
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
WHERE SAL >= 2000 
ORDER BY DEPTNO;

--P.226 Q2
SELECT E.DEPTNO, DNAME, FLOOR(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(*) AS CNT
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
GROUP BY E.DEPTNO, DNAME;

--P.226 Q3
SELECT D.DEPTNO, DNAME, EMPNO, ENAME, JOB, SAL 
FROM DEPT D LEFT OUTER JOIN EMP E ON (D.DEPTNO = E.DEPTNO)
ORDER BY D.DEPTNO, ENAME;

--P.227 Q4
SELECT D.DEPTNO, DNAME, E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO AS DEPTNO_1, LOSAL, HISAL, GRADE, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM DEPT D 
	LEFT OUTER JOIN EMP E1 ON (D.DEPTNO = E1.DEPTNO)
	LEFT OUTER JOIN SALGRADE S ON (E1.SAL BETWEEN LOSAL AND HISAL)
	LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY D.DEPTNO, E1.EMPNO;


SELECT ENAME, SAL FROM EMP e
WHERE SAL > (SELECT SAL
				FROM EMP
				WHERE ENAME ='JONES')

				
SELECT rownum, e.*
//줄 번호 매기기
FROM EMP E
ORDER BY SAL;

SELECT rownum, e.*
FROM (SELECT * FROM EMP ORDER BY SAL) e;


SELECT rownum RN, e.*
FROM (SELECT * FROM EMP ORDER BY SAL) e
WHERE RN BETWEEN 6 AND 10;
-- RN은 카운트 같은 기능이라 WHERE에 들어가면 1이 된다
--invalid identifier 나온다
--where가 select보다 먼저 동작하고 order by 가 나중에 동작해서 그렇다
--그래서 select로 감싼다

SELECT *
FROM (SELECT rownum AS RN, e.*
		FROM (SELECT * FROM EMP ORDER BY SAL) e)
WHERE RN BETWEEN 6 AND 10;


WITH E10 AS (
	SELECT * FROM EMP WHERE DEPTNO =10)
	
SELECT * FROM E10;

SELECT 
	SAL,
	ENAME,
	(SELECT
		GRADE
		FROM SALGRADE s 
		WHERE e.SAL BETWEEN losal AND hisal) AS grade
FROM emp e;		

SELECT * FROM emp;
SELECT * FROM DEPT d;
SELECT * FROM SALGRADE s;

--q1
--comm이 null인 사원을 급여 내름차순으로 정렬

SELECT * 
FROM emp
WHERE comm IS NULL
ORDER BY sal desc;


--q2
-- 급여 등급 별 사원 수를 등급 오름차순으로 정렬
-- 출력 : 등급, 몇명
SELECT grade, count(grade)
FROM SALGRADE s JOIN EMP e ON (sal BETWEEN losal AND hisal)
GROUP BY grade
ORDER BY grade;


--q3
-- 출력: 이름, 급여, 급여 등급, 부서 이름
-- 급여 등급 3 이상, 급여 등급 내림 차순, 
-- 급여 등급이 같은 경우 급여 내림 차순

SELECT ename, sal, grade, dname
FROM emp e JOIN DEPT d ON (e.DEPTNO = d.deptno)
			JOIN SALGRADE s  ON (sal BETWEEN losal AND hisal)
WHERE grade >=3
ORDER BY grade DESC, sal DESC;

--q4
-- 부서명이 SALES인 사원 중
-- 급여 등급이 2 또는 3인 사원 급여를 내림차순으로 정렬
SELECT dname, grade, sal 
FROM emp e JOIN DEPT d ON (e.DEPTNO = d.deptno)
			JOIN SALGRADE s  ON (sal BETWEEN losal AND hisal)
WHERE dname = 'SALES'
	AND (grade = 2 OR grade = 3)
ORDER BY sal desc;

--p249 q1
SELECT job, empno, ename, sal, e.deptno, dname
FROM emp e JOIN DEPT d ON (e.DEPTNO = d.deptno)
WHERE job =
		(SELECT job
		FROM EMP
		WHERE ename = 'ALLEN')
ORDER BY sal DESC, ename;


--p249 q2
SELECT empno, ename, dname, hiredate, loc, sal, grade
FROM EMP e JOIN dept d ON (e.DEPTNO = d.deptno)
			JOIN SALGRADE s ON (sal BETWEEN losal AND hisal)
WHERE sal >= (SELECT avg(sal) FROM emp) 
ORDER BY sal desc, empno;


--p249 q3
SELECT empno, ename, JOB, e.deptno, dname, LOC 
FROM EMP e JOIN dept d ON (e.DEPTNO = d.deptno)
			JOIN SALGRADE s ON (sal BETWEEN losal AND hisal)
WHERE e.deptno = 10
	AND job not in (SELECT job FROM emp WHERE deptno =30);


---p249 q4
SELECT empno,ename, sal, grade
FROM EMP e JOIN SALGRADE s ON (sal BETWEEN losal AND hisal)
WHERE sal > (SELECT max(sal) FROM emp WHERE job = 'SALESMAN')
ORDER BY empno;


DESC emp;
//dbeaver라서 안됨
SELECT * FROM emp;

CREATE TABLE emp_ddl(
	empno number(4),
	ename varchar2(10),
	job varchar2(9),
	mgr number(4),
	hiredate DATE,
	sal number(7,2),
	comm number(7,2),
	deptno number(2)
);

SELECT * FROM emp_ddl;

CREATE TABLE dept_ddl
AS SELECT * from dept;

SELECT * FROM dept_ddl;

CREATE TABLE empept_ddl
AS 
SELECT empno, ename, job job2, d.deptno, dname
FROM emp e, dept d
WHERE 1<> 1 ;

CREATE TABLE emp_alter
AS SELECT * FROM emp;
SELECT * FROM emp_alter;

ALTER TABLE emp_alter 
ADD hp varchar2(20);
SELECT * FROM emp_alter;

ALTER TABLE emp_alter
RENAME COLUMN hp TO tel;
SELECT * FROM emp_alter;

ALTER TABLE emp_alter
MODIFY empno number(5);

ALTER TABLE emp_alter
DROP COLUMN tel;
SELECT * FROM emp_alter

RENAME emp_alter TO emp_rename;

TRUNCATE TABLE emp_rename;

DROP TABLE emp_rename;

CREATE TABLE dept_temp
AS SELECT * FROM dept;


INSERT INTO dept_temp (deptno, dname, loc)
			VALUES (50, 'database', 'seoul');

INSERT INTO dept_temp
	VALUES (60, 'network', 'busan');

INSERT INTO dept_temp
	VALUES (70, '', null);

--DELETE FROM dept_temp WHERE dname =' ';

INSERT INTO dept_temp(deptno, loc)
	VALUES (90, 'incheon');

SELECT * FROM dept_temp;

CREATE TABLE emp_temp
	AS SELECT * FROM emp
	WHERE 1<>1;

INSERT INTO emp_temp (empno, ename, hiredate)
	VALUES (9999,'홍길동', '2026/01/27');

INSERT INTO emp_temp (empno, ename, hiredate)
	VALUES (7051,'최민수', to_date('2026-01-27','yyyy-mm-dd'));

INSERT INTO emp_temp (empno, ename, hiredate)
	VALUES (3111,'심청이', sysdate);

-----------------------------------------------------26.01.27

INSERT INTO EMP_TEMP 
SELECT * FROM emp WHERE deptno =10;

INSERT ALL
INTO  EMP_TEMP (empno,ename,hiredate)
	VALUES (3112,'심청이2',sysdate)
INTO  EMP_TEMP (empno,ename,hiredate)
	VALUES (3113,'심청이3',sysdate)
SELECT * FROM dual;

SELECT  * FROM EMP_TEMP;

CREATE TABLE dept_temp2
AS SELECT * FROM dept;

UPDATE dept_temp2
SET loc ='seoul';

ROLLBACK;

UPDATE dept_temp2
SET dname = 'database',
	loc ='seoul'
WHERE deptno = 40;

UPDATE dept_temp2
SET dname = (SELECT dname
				FROM dept
				WHERE deptno = 40),
	loc = (SELECT loc
				FROM dept
				WHERE deptno = 40)
WHERE deptno = 40;

SELECT * FROM dept_temp2;

CREATE TABLE EMP_Tmp 
AS SELECT * FROM emp;

SELECT sal, sal*1.08 FROM emp_tmp
WHERE sal < 1000;

UPDATE emp_tmp 
SET sal = sal*1.08
WHERE sal<1000;

SELECT sal, ename FROM emp_tmp
WHERE sal < 1080;

SELECT * from emp_tmp;

CREATE TABLE  emp_temp2
AS SELECT * FROM emp;

DELETE FROM emp_temp2
WHERE job = 'MANAGER';

DELETE emp_temp2;
ROLLBACK;

DELETE FROM emp_temp2
WHERE job = 'MANAGER';
COMMIT;
ROLLBACK;

SELECT * FROM emp_temp2;

SELECT  * FROM dict;
SELECT * FROM user_tables;


CREATE INDEX idx_emp_sal
ON emp(sal asc);

SELECT * FROM user_indexes;
SELECT * FROM user_ind_columns;

SELECT /*+ index(e idx_emp_sal) */ -- 강제 힌트
	ename, sal
FROM EMP e 
WHERE sal = 3000;

DROP INDEX idx_emp_sal;

CREATE VIEW vw_emp20
AS (SELECT empno, ename,job, deptno
	FROM emp 
	WHERE deptno = 20);

SELECT * FROM vw_emp20;

CREATE TABLE dept_seq
AS SELECT * FROM dept
WHERE 1 != 1;

SELECT * FROM dept_seq;

create SEQUENCE seq_dept;

SELECT seq_dept.nextval FROM dual;
SELECT seq_dept.currval FROM dual;

CREATE SEQUENCE seq_dept_10
START WITH 10
INCREMENT BY 10;


SELECT seq_dept_10.nextval FROM dual;
SELECT seq_dept_10.currval FROM dual;


INSERT INTO dept_seq(deptno,dname,loc)
values (seq_dept.nextval, 'database', 'seoul');

SELECT * FROM dept_seq;

CREATE TABLE table_pk(
	login_id varchar2(20) PRIMARY KEY,
	login_pwd varchar2(20) NOT NULL,
	tel varchar2(20)
);
--pk 하나만 지정 가능한 방법

INSERT INTO table_pk
VALUES ('id1', 'pw1',NULL);

INSERT INTO table_pk
VALUES ('id2', NULL ,NULL);

INSERT INTO table_pk(login_id)
values(null);

UPDATE table_pk
SET login_id =NULL
WHERE login_id = 'id1';

INSERT INTO table_pk
VALUES ('id2', 'pw2' ,NULL);

UPDATE table_pk
SET login_id = 'id1'
WHERE login_id = 'id2';

SELECT * FROM table_pk;
SELECT * FROM user_indexes;


CREATE TABLE table_pk2(
	login_id varchar2(20) ,
	login_pwd varchar2(20) ,
	tel varchar2(20),
	
	PRIMARY KEY (login_id, tel)
);

--pk를 여러개 지정 가능한 방법
CREATE TABLE table_pk3(
	login_id varchar2(20) ,
	login_pwd varchar2(20) ,
	tel varchar2(20)
);

ALTER TABLE table_pk3
add PRIMARY KEY (login_id, tel);

--modify는 pk하나 지정 가능
ALTER TABLE table_pk3
MODIFY login_id PRIMARY key;

CREATE TABLE dept_fk(
	deptno number(2) PRIMARY KEY,
	dname varchar2(24),
	loc varchar2(13)
);

CREATE TABLE emp_fk(
	empno number(4) PRIMARY KEY,
	ename varchar2(10),
	deptno number(2) REFERENCES dept_fk(deptno)
);


INSERT INTO emp_fk
VALUES (1,'이름',null);



